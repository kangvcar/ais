---
description: 
globs: 
alwaysApply: true
---
### **`ais`: 终端 AI 助手 - 详细设计与开发计划 **

本文档旨在为 `ais` 项目提供一份精确、可执行的蓝图，并完全采纳你的最新指示。

#### **第一部分：项目设计与架构**

**1. 项目管理工具：UV**

我们将使用 `uv` 作为项目唯一的依赖管理和虚拟环境工具。`uv` 由 `ruff` 的作者开发，以其极高的性能著称，是管理现代 Python 项目的绝佳选择。所有相关命令都将围绕 `uv` 展开。

**2. 核心组件详解**

* **`cli.py` (CLI 入口)**
    * **技术栈**: **Typer**
    * **职责**:
        1.  定义所有命令入口：`ais` 的默认问答，以及 `fix`, `config`, `report` 子命令。
        2.  处理 `ais <问题>` 形式的直接查询：通过 Typer 的回调机制实现，当没有调用任何子命令时，将所有位置参数拼接为一句完整的自然语言问题。
        3.  **流式输出处理**: 从 `ai_providers` 模块获取一个流式响应的迭代器。循环遍历此迭代器，将收到的每一个数据块（token）**立即**打印到终端，实现文字的实时显示。
        4.  协调其他模块完成特定任务，是整个应用的“总指挥”。

* **`shell_integration` (Shell 集成)**
    * **技术栈**: **Bash Script**
    * **职责**: 提供 `scripts/ais_shell_setup.sh` 脚本，用于实现与 Bash 的深度集成。
    * **具体实现**:
        1.  **错误捕获**: 使用 `trap 'error_code=$?; history -s "ais-err-marker";' ERR`。当命令出错时，`trap` 会被触发，记录退出码，并通过 `history -s` 将一个特殊标记写入历史记录，便于 `ais fix` 定位到出错的命令。
        2.  **错误提示**: `PROMPT_COMMAND` 钩子会检查上一条命令的退出码。如果非零（且不是由 `Ctrl+C` 导致），则在显示新的提示符之前，打印 `💡 Command failed. Run 'ais fix' (or press Ctrl+A) for an AI suggestion.`
        3.  **快捷键绑定**: 使用 `bind -x '"\C-a": "ais fix"'` 命令，将 `Ctrl+A` 快捷键直接映射到执行 `ais fix` 命令。

* **`ai_providers.py` (AI 服务)**
    * **技术栈**: **Groq Python SDK**
    * **职责**:
        1.  定义一个统一的接口（例如一个 `get_streaming_suggestion` 函数）。
        2.  实现与 Groq API 的通信逻辑，**必须启用流式模式**（即在 API 调用时设置 `stream=True`）。
        3.  函数将返回一个可供 `cli.py` 消费的流式响应迭代器。
        4.  初期版本将**内置一个可用的 Groq API 密钥**，实现用户的零配置启动。

* **`interaction.py` (高级交互)**
    * **技术栈**: **`prompt_toolkit`**
    * **职责**:
        1.  实现最高集成度的**行内编辑功能**。
        2.  提供一个函数 `prompt_for_action(suggested_command)`，它会接收 AI 建议的命令，然后向用户展示选项。
        3.  当用户选择“编辑(Modify)”时，此模块会使用 `prompt_toolkit` 在当前光标位置创建一个可交互的编辑行，用户修改完毕按回车后，返回最终的命令字符串。

* **`database.py` (数据持久化)**
    * **技术栈**: **SQLite** (通过 `sqlite3` 标准库) + **SQLModel**
    * **职责**:
        1.  **数据记录将默认开启**。
        2.  定义 `CommandLog` 数据模型，该模型将明确包含以下字段：`timestamp`, `username`, `original_command`, `stderr_output`, `ai_suggestion`, `user_action` (执行/编辑/取消), `final_command`。
        3.  **完整存储信息**：我们将**完整存储用户的命令原文、错误输出、AI建议以及用户的最终选择**到 `~/.local/share/ais/history.db` 的本地数据库中。

---

#### **第二部分：分阶段开发 TODO 列表**

这是一个更细化的、可操作的开发步骤清单。

**▶️ Phase 0: 项目初始化与环境配置 (使用 UV)**

* [ ] 1. 创建项目根目录 `ais/` 并初始化 Git 仓库。
* [ ] 2. 创建 Python 虚拟环境: `uv venv`
* [ ] 3. 激活虚拟环境: `source .venv/bin/activate`
* [ ] 4. 在 `pyproject.toml` 的 `[project]` 表中定义项目名称、版本等，并在 `dependencies` 数组中加入: `"typer[all]"`、`"rich"`、`"groq"`、`"prompt-toolkit"`、`"sqlmodel"`。
* [ ] 5. 安装依赖: `uv pip install -r requirements.txt` (如果使用 `uv lock` 生成了 `requirements.txt`) 或直接 `uv pip install typer[all] rich groq prompt-toolkit sqlmodel`。
* [ ] 6. 创建 `src/ais/`、`scripts/` 和 `tests/` 目录结构。

**▶️ Phase 1: MVP - 核心流式 AI 对话**

*此阶段目标：让 `ais <问题>` 可以工作，并实现流式输出。*

* [ ] 1. **(ai_providers.py)**: 创建 `GroqProvider` 类或函数。实现一个 `get_streaming_response(prompt: str)` 方法，该方法调用 `groq.chat.completions.create` 时**必须设置 `stream=True`**，并返回 API 响应的流对象。
* [ ] 2. **(cli.py)**: 使用 Typer 创建 `main` 函数和默认回调。
* [ ] 3. **(cli.py)**: 在回调函数中，调用 `get_streaming_response` 获取流。
* [ ] 4. **(cli.py)**: 循环遍历流对象 (`for chunk in stream:`), 从 `chunk.choices[0].delta.content` 中提取文本，并使用 `print(text, end="", flush=True)` **立即输出到终端**，以实现打字机效果。
* [ ] 5. **(测试)**: 运行 `uv run ais "用python写一个快速排序"`，验证文字是否逐字流式显示。

**▶️ Phase 2: Shell 集成与上下文感知**

*此阶段目标：让 `ais fix` 能够被触发并获取到正确的错误上下文。*

* [ ] 1. **(scripts/ais_shell_setup.sh)**: 严格按照设计部分的描述，编写 Bash 脚本，实现 `trap ERR`, `PROMPT_COMMAND` 和 `bind` 快捷键。
* [ ] 2. **(context.py)**: 实现 `get_error_context()` 函数。
    * 该函数通过 `history` 命令和我们埋下的 `ais-err-marker` 标记，来准确找到并提取出错的命令原文。
    * (需要 shell 脚本辅助) `trap` 错误时，将 stderr 重定向到一个固定路径的临时文件，例如 `/tmp/ais_last_error.log`。`get_error_context()` 函数则从该文件读取 stderr 内容。
    * 调用 `os.getcwd()`, `os.listdir()`, `subprocess.run(['git', 'status'])` 等收集其他上下文信息。
* [ ] 3. **(cli.py)**: 实现 `ais fix` 子命令。
    * 调用 `context.py.get_error_context()`。
    * 将所有上下文信息格式化成一个高质量的 Prompt。
    * 将此 Prompt 发送给 `ai_providers` 模块，并以**流式**方式打印 AI 的分析和建议。

**▶️ Phase 3: 高级交互与数据持久化**

*此阶段目标：实现 "执行/编辑/取消" 的闭环，并记录所有交互。*

* [ ] 1. **(database.py)**: 使用 SQLModel 定义 `CommandLog` 表模型，并编写 `create_db_and_tables()` 和 `add_log_entry()` 函数。
* [ ] 2. **(interaction.py)**: 使用 `prompt_toolkit` 实现 `prompt_for_action(suggested_command)` 函数，提供行内编辑功能。
* [ ] 3. **(cli.py)**: 修改 `ais fix` 命令的末端逻辑。在 AI 流式输出其建议后，调用 `prompt_for_action`。
* [ ] 4. **(cli.py/database.py)**:
    * 在 `ais fix` 开始时就记录部分日志（原始命令、错误）。
    * 根据 `prompt_for_action` 的返回值（执行、编辑后的命令、取消），补全日志条目并存入数据库。
    * 如果用户选择执行，则使用 `subprocess.run` 来执行最终的命令。

**▶️ Phase 4: 用户功能与最终打磨**

*此阶段目标：完成辅助功能，并提升产品完整度。*

* [ ] 1. **(config.py)**: 实现 `TOML` 格式配置文件的读取与写入。
* [ ] 2. **(cli.py)**: 实现 `ais config` 子命令，允许用户未来设置自己的 API 密钥或切换 AI Provider。
* [ ] 3. **(cli.py)**: 实现 `ais report` 子命令，从 SQLite 数据库查询数据并使用 `rich.table.Table` 美观地展示用户的使用分析。
* [ ] 4. **(渲染增强)**: 改进流式输出的最终效果。在流式输出文本的同时，将所有文本拼接成一个完整的字符串。当流结束后，使用 `rich.markdown.Markdown` 将这个完整字符串**重新渲染一次**，以获得最佳的代码高亮和格式化效果。
* [ ] 5. **(文档与打包)**: 编写详细的 `README.md`，包括 `uv` 安装步骤和 `source` shell 脚本的说明。配置 `pyproject.toml` 以支持通过 `uv pip install .` 进行本地安装。